# **Descripción breve del software LTI**

### Descripción Breve del Software LTI

LTI ATS es una plataforma de reclutamiento de última generación que integra inteligencia artificial, automatización y colaboración en tiempo real para transformar la experiencia de los departamentos de Recursos Humanos. Con una interfaz intuitiva y un enfoque centrado en la eficiencia, LTI permite:

Optimizar los procesos de contratación: Automatiza tareas repetitivas y agiliza la preselección de candidatos.
Mejorar la colaboración: Facilita la comunicación en tiempo real entre reclutadores y managers a través de herramientas integradas (chat, comentarios, reuniones virtuales).
Aumentar la calidad en la selección: Emplea algoritmos de IA para filtrar, clasificar y predecir el éxito de los candidatos, reduciendo errores y sesgos.
Integrar múltiples canales: Se conecta fácilmente con portales de empleo, herramientas HRIS, calendarios y otros sistemas, centralizando toda la información en una única plataforma.

### Valor Añadido y Ventajas Competitivas

Valor Añadido:

Eficiencia Operativa: Reducción significativa del tiempo dedicado a tareas manuales y administrativas.
Decisiones Basadas en Datos: Dashboards y analíticas en tiempo real que permiten medir el rendimiento del proceso de reclutamiento.
Experiencia Integral: Una solución que cuida tanto la experiencia del usuario interno (HR y managers) como la del candidato, garantizando transparencia y feedback en cada etapa.

Ventajas Competitivas:

Inteligencia Artificial Avanzada: Uso de algoritmos de machine learning para mejorar la preselección y ranking de candidatos.
Automatización Inteligente: Automatización de procesos clave (publicación de ofertas, programación de entrevistas, seguimiento de candidatos) que libera recursos y mejora la eficiencia.
Colaboración en Tiempo Real: Herramientas integradas que permiten a los equipos de HR trabajar conjuntamente de manera sincronizada, facilitando la toma de decisiones y reduciendo tiempos de respuesta.
Interfaz de Usuario Moderna y Adaptable: Diseño centrado en la usabilidad y la experiencia tanto para reclutadores como para candidatos, asegurando una alta tasa de adopción y satisfacción.
Escalabilidad y Flexibilidad: Capacidad de adaptarse a diferentes tamaños de empresa y sectores, permitiendo la integración con múltiples herramientas y plataformas externas.

### Funciones Principales del ATS LTI

Gestión Centralizada de Candidatos:

Base de datos unificada para almacenar y gestionar currículums y perfiles.
Etiquetado y clasificación de candidatos para búsquedas rápidas y segmentación.

Publicación Multicanal:

Distribución automática de ofertas en portales de empleo, redes sociales y sitios web.
Integración con APIs de terceros para ampliar el alcance de las publicaciones.

Filtrado y Preselección Automatizada:

Algoritmos de IA que analizan currículums y aplican criterios de selección basados en experiencia, habilidades y compatibilidad.
Ranking automático de candidatos para identificar rápidamente los perfiles más prometedores.

Colaboración en Tiempo Real:

Herramientas de comunicación interna (chat, comentarios, notificaciones) para que reclutadores y managers colaboren de manera ágil.
Espacios de trabajo compartidos donde se puede seguir el progreso de cada candidato y coordinar feedback e entrevistas.

Automatización de Procesos:

Programación y recordatorios automáticos para entrevistas y reuniones.
Flujo de trabajo automatizado que actualiza el estado del candidato en cada etapa del proceso.
Generación automática de reportes y dashboards con indicadores clave (KPIs).

Analíticas y Reportes:

Dashboard en tiempo real para monitorizar métricas como tiempo de contratación, tasa de conversión y origen de los candidatos.
Herramientas de análisis predictivo que permiten ajustar estrategias de reclutamiento en función de resultados históricos.

Integraciones y Conectividad:

Conexión con sistemas HRIS, CRM, calendarios y otras herramientas de gestión empresarial.
APIs abiertas que permiten la integración con soluciones personalizadas y futuras tecnologías.

### Lean Canvas: Modelo de Negocio para LTI ATS

A continuación se detalla un Lean Canvas que sintetiza los elementos clave del modelo de negocio de LTI ATS:

```
────────────────────────────────────────────
1. Problema:
   - Procesos de reclutamiento manuales y poco eficientes.
   - Falta de colaboración en tiempo real entre reclutadores y managers.
   - Dificultad para filtrar candidatos de calidad en grandes volúmenes.
   - Herramientas ATS existentes con interfaces anticuadas y poca integración.

────────────────────────────────────────────
2. Segmentos de Clientes:
   - Departamentos de Recursos Humanos en startups y PYMES.
   - Grandes empresas y corporativos.
   - Empresas tecnológicas en búsqueda de digitalización.
   - Agencias de reclutamiento y consultoras.

────────────────────────────────────────────
3. Propuesta de Valor Única:
   - "El ATS del futuro": Una plataforma integral que combina IA, automatización y colaboración en tiempo real para revolucionar la eficiencia y calidad del proceso de reclutamiento.

────────────────────────────────────────────
4. Solución:
   - Plataforma centralizada para la gestión avanzada de candidatos.
   - Automatización inteligente de tareas (publicación, programación, seguimiento).
   - Herramientas integradas para colaboración y comunicación en tiempo real.
   - Analíticas y dashboards en tiempo real para toma de decisiones.

────────────────────────────────────────────
5. Canales:
   - Marketing digital (SEO, SEM, redes sociales).
   - Alianzas estratégicas con consultoras de HR y agencias de reclutamiento.
   - Participación en ferias y conferencias de recursos humanos y tecnología.
   - Ventas directas y demostraciones personalizadas.

────────────────────────────────────────────
6. Fuentes de Ingresos:
   - Modelo SaaS basado en suscripción (mensual/anual).
   - Precios escalonados según funcionalidades y número de usuarios.
   - Servicios adicionales: consultoría, personalización e integraciones avanzadas.

────────────────────────────────────────────
7. Estructura de Costos:
   - Desarrollo y mantenimiento de la plataforma.
   - Costos de integración y actualizaciones tecnológicas.
   - Gastos en marketing y adquisición de clientes.
   - Soporte técnico, atención al cliente y formación.
   - Infraestructura en la nube, seguridad y cumplimiento normativo.

────────────────────────────────────────────
8. Métricas Clave:
   - Tasa de conversión de leads a clientes.
   - Tiempo de implementación y adopción de la plataforma.
   - Satisfacción del cliente (NPS, feedback).
   - Reducción en el tiempo de contratación.
   - ROI y eficiencia operativa en los departamentos de HR.

────────────────────────────────────────────
9. Ventaja Competitiva (Unfair Advantage):
   - Integración exclusiva de IA y automatización en el flujo de reclutamiento.
   - Herramientas de colaboración en tiempo real que facilitan decisiones conjuntas.
   - Plataforma escalable y adaptable a múltiples sectores y tamaños de empresa.
   - Enfoque en experiencia de usuario superior tanto para HR como para candidatos.
   - Innovación continua basada en análisis de datos y feedback del mercado.
────────────────────────────────────────────


```

Claves del Éxito y Errores Comunes a Evitar

Claves del Éxito:

Innovación Constante: Incorporar tecnologías emergentes (como IA y machine learning) para mantener la plataforma a la vanguardia.
Enfoque en el Usuario: Diseñar una experiencia intuitiva para todos los usuarios (HR, managers y candidatos), asegurando facilidad de uso y alta adopción.
Integración y Flexibilidad: Ofrecer integraciones nativas con otras herramientas y ser adaptable a diferentes flujos de trabajo y sectores.
Colaboración y Comunicación: Fomentar la interacción en tiempo real entre equipos para mejorar la toma de decisiones y reducir tiempos de respuesta.
Seguridad y Cumplimiento: Garantizar la protección de datos y cumplir con normativas (como GDPR), lo cual es fundamental en el manejo de información sensible.

Errores Comunes a Evitar:

Sobrecargar la Plataforma: Incluir demasiadas funcionalidades desde el inicio puede afectar la usabilidad. Es mejor priorizar un MVP con funcionalidades esenciales e ir iterando.
Falta de Feedback: No involucrar a los usuarios finales en el proceso de desarrollo y pruebas puede llevar a un producto que no responde a sus necesidades.
Desatender la Integración: Ignorar la necesidad de conectarse con otras herramientas y sistemas puede limitar la adopción y escalabilidad del ATS.
Ignorar la Seguridad: No dar la debida importancia a la seguridad de la información puede generar problemas legales y pérdida de confianza.
No Adaptarse al Mercado: La falta de flexibilidad y actualización constante frente a nuevas tendencias y tecnologías puede dejar el producto rezagado frente a la competencia.

# 2. **Descripción de los 3 casos de uso principales**

1. Crear y Publicar Oferta de Empleo
   Descripción:
   El reclutador crea una oferta de empleo ingresando todos los detalles relevantes (descripción del puesto, requisitos, ubicación, etc.) y selecciona los canales (portales de empleo, redes sociales, etc.) en los que desea publicar la oferta. La plataforma se encarga de distribuir la oferta automáticamente a través de las integraciones configuradas.

2. Gestión de Candidatos
   Descripción:
   Este caso de uso abarca la recepción, almacenamiento y organización de las aplicaciones de los candidatos. Cuando un candidato se postula a una oferta, su información y CV se registran en la base de datos del sistema. Además, se aplican filtros y criterios de preselección (posiblemente asistidos por IA) para ayudar al reclutador a identificar rápidamente los perfiles más relevantes.

3. Colaboración y Seguimiento del Proceso de Selección
   Descripción:
   Los reclutadores y gerentes de contratación colaboran en tiempo real para evaluar a los candidatos. Este caso de uso permite actualizar el estado de cada candidato, agendar entrevistas, intercambiar feedback y gestionar el flujo completo del proceso de selección. La herramienta facilita la comunicación entre todos los actores involucrados para acelerar la toma de decisiones.

```
%% Diagrama de Casos de Uso para LTI ATS - Funcionalidad Básica
usecaseDiagram
    actor "Reclutador" as R
    actor "Gerente de Contratación" as G
    actor "Candidato" as C

    (Crear y Publicar Oferta de Empleo) as CU1
    (Gestión de Candidatos) as CU2
    (Colaboración y Seguimiento de Selección) as CU3

    R --> CU1
    R --> CU2
    C --> CU2 : Postula a oferta
    R --> CU3
    G --> CU3



```

Este diagrama representa de forma clara los actores involucrados y los casos de uso principales que permiten lograr una funcionalidad básica en el ATS LTI. Cada caso de uso es fundamental para el flujo de trabajo:

CU1 (Crear y Publicar Oferta de Empleo): Permite iniciar el proceso de reclutamiento.
CU2 (Gestión de Candidatos): Centraliza la recepción y el filtrado de las aplicaciones.
CU3 (Colaboración y Seguimiento de Selección): Facilita la comunicación y coordinación entre reclutadores y gerentes.

# 3. **Modelo de datos**

Entidades y Campos Principales
User (Usuario)
Representa a los usuarios internos del sistema, tales como reclutadores y gerentes de contratación.
Atributos:

id: UUID
name: String
email: String
role: String (por ejemplo, "Recruiter", "Hiring Manager")
createdAt: DateTime
updatedAt: DateTime
OfertaEmpleo (Job Posting / Oferta de Empleo)
Representa la oferta de empleo creada y publicada por un reclutador.
Atributos:

id: UUID
title: String
description: Text
requirements: Text
location: String
employmentType: String (por ejemplo, "Full-Time", "Part-Time")
datePosted: DateTime
dateClosing: DateTime (opcional)
channels: List<String> (canales de publicación, por ejemplo, "LinkedIn", "Indeed")
createdBy: UUID (referencia al User que creó la oferta)
Candidate (Candidato)
Representa a la persona que postula a una oferta de empleo.
Atributos:

id: UUID
name: String
email: String
phone: String
resume: Text (o URL al archivo del CV)
linkedInProfile: String (opcional)
createdAt: DateTime
updatedAt: DateTime
Application (Postulación)
Representa la aplicación de un candidato a una oferta de empleo concreta.
Atributos:

id: UUID
candidateId: UUID (referencia a Candidate)
jobPostingId: UUID (referencia a OfertaEmpleo)
applicationDate: DateTime
status: String (por ejemplo, "Applied", "In Review", "Interviewed", "Rejected", "Hired")
notes: Text (comentarios generales sobre la aplicación)
rating: Float (opcional, para evaluar la aplicación)
Interview (Entrevista)
Registra los detalles de una entrevista agendada como parte del proceso de selección para una aplicación.
Atributos:

id: UUID
applicationId: UUID (referencia a Application)
scheduledDate: DateTime
interviewType: String (por ejemplo, "Phone", "Video", "In-Person")
participants: List<UUID> (referencias a los User que participan en la entrevista)
feedback: Text (comentarios o resumen de la entrevista)
Feedback (Retroalimentación)
Representa comentarios o evaluaciones realizadas por un usuario (reclutador o gerente) respecto a una aplicación o entrevista.
Atributos:

id: UUID
applicationId: UUID (referencia a Application)
userId: UUID (referencia al User que proporciona la retroalimentación)
comment: Text
rating: Float
createdAt: DateTime
Relaciones Entre Entidades
User — OfertaEmpleo:
Un User (reclutador) puede crear y publicar varias OfertaEmpleo.
Relación: Uno a Muchos (1 User crea N OfertaEmpleo)

OfertaEmpleo — Application:
Una OfertaEmpleo puede recibir múltiples Application (postulaciones).
Relación: Uno a Muchos (1 OfertaEmpleo tiene N Application)

Candidate — Application:
Un Candidate puede postularse a varias ofertas, generando múltiples Application.
Relación: Uno a Muchos (1 Candidate genera N Application)

Application — Interview:
Una Application puede incluir una o varias Interview durante el proceso de selección.
Relación: Uno a Muchos (1 Application tiene N Interview)

Application — Feedback:
Una Application puede recibir múltiples Feedback de distintos usuarios.
Relación: Uno a Muchos (1 Application recibe N Feedback)

User — Feedback:
Un User puede proveer múltiples Feedback para diferentes aplicaciones o entrevistas.
Relación: Uno a Muchos (1 User genera N Feedback)

Diagrama de Clases en Mermaid
A continuación se muestra un diagrama de clases en formato Mermaid que representa las entidades, sus atributos principales y las relaciones entre ellas:

```
%% Diagrama de Clases para el modelo de dominio del ATS LTI
classDiagram
    %% Clase User
    class User {
      +UUID id
      +String name
      +String email
      +String role
      +DateTime createdAt
      +DateTime updatedAt
    }

    %% Clase OfertaEmpleo
    class OfertaEmpleo {
      +UUID id
      +String title
      +Text description
      +Text requirements
      +String location
      +String employmentType
      +DateTime datePosted
      +DateTime dateClosing
      +List~String~ channels
      +UUID createdBy
    }

    %% Clase Candidate
    class Candidate {
      +UUID id
      +String name
      +String email
      +String phone
      +Text resume
      +String linkedInProfile
      +DateTime createdAt
      +DateTime updatedAt
    }

    %% Clase Application
    class Application {
      +UUID id
      +UUID candidateId
      +UUID jobPostingId
      +DateTime applicationDate
      +String status
      +Text notes
      +Float rating
    }

    %% Clase Interview
    class Interview {
      +UUID id
      +UUID applicationId
      +DateTime scheduledDate
      +String interviewType
      +List~UUID~ participants
      +Text feedback
    }

    %% Clase Feedback
    class Feedback {
      +UUID id
      +UUID applicationId
      +UUID userId
      +Text comment
      +Float rating
      +DateTime createdAt
    }

    %% Relaciones
    User "1" --> "0..*" OfertaEmpleo : crea
    OfertaEmpleo "1" --> "0..*" Application : recibe
    Candidate "1" --> "0..*" Application : postula
    Application "1" --> "0..*" Interview : incluye
    Application "1" --> "0..*" Feedback : recibe
    User "1" --> "0..*" Feedback : proporciona

```

Explicación Adicional
User y OfertaEmpleo:
Cada oferta de empleo tiene un atributo createdBy que referencia el id del User (reclutador) que la creó. Esto facilita el seguimiento de quién publica cada oferta.

Candidate y Application:
La entidad Application actúa como puente entre Candidate y OfertaEmpleo, permitiendo gestionar múltiples postulaciones de un mismo candidato y el seguimiento de cada proceso de selección.

Application y sus Subprocesos:
Cada Application puede tener asociadas múltiples entrevistas (Interview) y retroalimentaciones (Feedback), lo que permite capturar todo el historial y la evolución del proceso de selección para cada candidato.

Este diseño modular y orientado a objetos permite que el sistema sea escalable, facilite integraciones futuras (por ejemplo, con módulos de análisis avanzado o nuevas herramientas de comunicación) y mantenga una trazabilidad clara en todo el proceso de reclutamiento.

# 4. **Diseño del sistema a alto nivel**

A continuación se muestra una propuesta de diseño a alto nivel para el ATS LTI utilizando una arquitectura hexagonal e incluyendo componentes comunes (CDN, Reverse Proxy, Load Balancer, Cache, Colas, etc.). Este diseño respeta las buenas prácticas de separación de responsabilidades, escalabilidad y resiliencia:

Clientes:
Los usuarios (candidatos, reclutadores y gerentes) interactúan mediante aplicaciones web o móviles. Los activos estáticos se sirven a través de un CDN para mejorar el rendimiento global.

Capa de Entrada:
Se utiliza un Reverse Proxy (por ejemplo, Nginx) que recibe las peticiones y actúa como punto de entrada, ofreciendo seguridad y manejo de certificados SSL. A continuación, un Load Balancer distribuye el tráfico entre múltiples instancias de la aplicación.

Capa de Aplicación (Hexagonal):
En el núcleo se encuentra la Arquitectura Hexagonal o “puertos y adaptadores”.

Core Domain: Contiene la lógica de negocio y reglas de la aplicación.
Aplicación/Servicios: Define casos de uso y coordina la interacción entre el dominio y los adaptadores.
Adaptadores de Entrada/Salida: Interfaces que permiten comunicarse con sistemas externos (bases de datos, servicios externos, colas de mensajería, cache, etc.).
Infraestructura:

Base de Datos: Motor de persistencia (relacional o NoSQL) para almacenar la información.
Cache: Sistema (por ejemplo, Redis) para acelerar lecturas frecuentes y reducir la carga en la base de datos.
Message Queue (Colas): Sistema de colas (RabbitMQ, Kafka) para manejar tareas asíncronas y desacoplar procesos intensivos.
Servicios Externos:
Integraciones con servicios de terceros (por ejemplo, verificación de CV, notificaciones, etc.) que se comunican mediante adaptadores específicos.

A continuación, se presenta el diagrama en formato XML para importarlo en draw.io:

```
<?xml version="1.0" encoding="UTF-8"?>
<mxfile host="app.diagrams.net" modified="2025-02-09T00:00:00.000Z" agent="ChatGPT" version="16.0.0" type="device">
  <diagram id="diagram1" name="Arquitectura ATS LTI - Alto Nivel">
    <mxGraphModel dx="1220" dy="775" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <!-- Clientes -->
        <mxCell id="2" value="Cliente (Web/Móvil)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#000000;" vertex="1" parent="1">
          <mxGeometry x="20" y="20" width="140" height="60" as="geometry" />
        </mxCell>
        <!-- CDN -->
        <mxCell id="3" value="CDN" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;" vertex="1" parent="1">
          <mxGeometry x="200" y="20" width="120" height="60" as="geometry" />
        </mxCell>
        <!-- Reverse Proxy -->
        <mxCell id="4" value="Reverse Proxy" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#ffe6cc;strokeColor=#d79b00;" vertex="1" parent="1">
          <mxGeometry x="360" y="20" width="140" height="60" as="geometry" />
        </mxCell>
        <!-- Load Balancer -->
        <mxCell id="5" value="Load Balancer" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="540" y="20" width="140" height="60" as="geometry" />
        </mxCell>
        <!-- Application Server Container (Arquitectura Hexagonal) -->
        <mxCell id="6" value="Application Server (Hexagonal)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;" vertex="1" parent="1">
          <mxGeometry x="720" y="0" width="300" height="240" as="geometry" />
        </mxCell>
        <!-- Núcleo del Dominio dentro del Application Server -->
        <mxCell id="7" value="Domain Core" style="ellipse;whiteSpace=wrap;html=1;fillColor=#ffffff;strokeColor=#000000;" vertex="1" parent="6">
          <mxGeometry x="100" y="90" width="100" height="60" as="geometry" />
        </mxCell>
        <!-- Adaptadores (Ejemplos de puertos de salida) -->
        <mxCell id="8" value="DB Adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#e1d5e7;strokeColor=#9673a6;" vertex="1" parent="6">
          <mxGeometry x="10" y="10" width="100" height="40" as="geometry" />
        </mxCell>
        <mxCell id="9" value="Cache Adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#fff2cc;strokeColor=#d6b656;" vertex="1" parent="6">
          <mxGeometry x="190" y="10" width="100" height="40" as="geometry" />
        </mxCell>
        <mxCell id="10" value="Queue Adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="6">
          <mxGeometry x="10" y="190" width="100" height="40" as="geometry" />
        </mxCell>
        <mxCell id="11" value="External Service Adapter" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;" vertex="1" parent="6">
          <mxGeometry x="190" y="190" width="100" height="40" as="geometry" />
        </mxCell>
        <!-- Infraestructura Externa -->
        <mxCell id="12" value="Base de Datos" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#e1d5e7;strokeColor=#9673a6;" vertex="1" parent="1">
          <mxGeometry x="720" y="260" width="140" height="60" as="geometry" />
        </mxCell>
        <mxCell id="13" value="Cache (Redis)" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#fff2cc;strokeColor=#d6b656;" vertex="1" parent="1">
          <mxGeometry x="880" y="260" width="140" height="60" as="geometry" />
        </mxCell>
        <mxCell id="14" value="Message Queue" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="1040" y="260" width="140" height="60" as="geometry" />
        </mxCell>
        <!-- Conexiones entre componentes -->
        <mxCell id="15" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;exitPerimeter=1;" edge="1" parent="1" source="2" target="3">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="16" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;exitPerimeter=1;" edge="1" parent="1" source="3" target="4">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="17" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;exitPerimeter=1;" edge="1" parent="1" source="4" target="5">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="18" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;exitPerimeter=1;" edge="1" parent="1" source="5" target="6">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <!-- Conexiones de la capa hexagonal con la infraestructura -->
        <mxCell id="19" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;" edge="1" parent="1" source="6" target="12">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="20" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;" edge="1" parent="1" source="6" target="13">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="21" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;" edge="1" parent="1" source="6" target="14">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>


```

Explicación del Diagrama
Entrada del Sistema:

Cliente (Web/Móvil): Los usuarios interactúan con la aplicación.
CDN: Distribuye y cachea los recursos estáticos (imágenes, CSS, JS) para mejorar la experiencia.
Reverse Proxy: Maneja la seguridad, SSL y enrutamiento inicial de las peticiones.
Load Balancer: Distribuye el tráfico entre las múltiples instancias del servidor de aplicación.
Capa de Aplicación (Hexagonal):

Application Server (Hexagonal): Contiene la lógica central de negocio.
Domain Core: El núcleo de la lógica de negocio.
Adaptadores: Puertos y adaptadores para conectarse con servicios externos, bases de datos, cache, y colas.
Infraestructura:

Base de Datos, Cache y Message Queue: Sistemas de infraestructura que soportan la persistencia, la mejora de rendimiento y el procesamiento asíncrono de tareas.
Este diseño, basado en la arquitectura hexagonal y componentes de infraestructura modernos, facilita el desacoplamiento, la escalabilidad y la capacidad de incorporar futuras mejoras o integraciones sin afectar la lógica de negocio central.

# 5. Diagrama C4

A continuación se presenta un diagrama C4 de nivel 2 (Contenedores) para el ATS LTI. Este diagrama descompone el sistema en varios contenedores, especificando la tecnología principal (o ejemplos de tecnologías) en cada uno y mostrando cómo se comunican entre ellos. La solución se basa en una arquitectura hexagonal en el backend, lo que permite que la lógica de negocio (Domain Services) se desacople de los mecanismos de entrada/salida.

Puedes copiar el siguiente código en draw.io (usando la opción de importar XML) o utilizar una herramienta compatible con Mermaid para visualizarlo.

```
flowchart TD
  %% Clientes (Interfaz de Usuario)
  subgraph Clientes [Clientes]
    WA[Web Application<br/>(React)]
    MA[Mobile Application<br/>(React Native)]
  end

  %% Capa de Edge (Entrega de Contenido y Enrutamiento)
  subgraph "Capa de Edge" [Capa de Edge]
    CDN[CDN<br/>(Cloudflare/CloudFront)]
    RP[Reverse Proxy<br/>(Nginx)]
    LB[Load Balancer<br/>(HAProxy)]
  end

  %% Backend principal (LTI ATS)
  subgraph "Backend LTI ATS" [Backend LTI ATS]
    API[API Gateway / Application Server<br/>(Spring Boot / Node.js)]
    DS[Domain Services<br/>(Arquitectura Hexagonal)]
  end

  %% Almacenamiento y Mensajería
  subgraph "Data & Messaging" [Almacenamiento y Mensajería]
    DB[(Base de Datos<br/>(PostgreSQL))]
    Cache[(Cache<br/>(Redis))]
    MQ[(Message Queue<br/>(RabbitMQ))]
  end

  %% Servicios Externos
  subgraph "Servicios Externos" [Servicios Externos]
    EXT[External Integrations<br/>(Email, SMS, etc.)]
  end

  %% Flujo de comunicaciones entre contenedores
  WA --> CDN
  MA --> CDN
  CDN --> RP
  RP --> LB
  LB --> API
  API --> DS
  DS --> DB
  DS --> Cache
  DS --> MQ
  API -- "REST/HTTP" --> EXT


```

Descripción de los Contenedores y su Comunicación
Clientes:

Web Application (React): Es la aplicación web que utilizan reclutadores, gerentes y candidatos para interactuar con el sistema.
Mobile Application (React Native): Aplicación móvil que permite la interacción en dispositivos móviles.
Capa de Edge:

CDN (Cloudflare/CloudFront): Distribuye y cachea contenido estático (imágenes, scripts, hojas de estilo) para mejorar la latencia y rendimiento global.
Reverse Proxy (Nginx): Se encarga de gestionar la seguridad (SSL/TLS) y enrutamiento inicial de las solicitudes.
Load Balancer (HAProxy): Distribuye las peticiones entrantes entre las distintas instancias del backend para asegurar escalabilidad y alta disponibilidad.
Backend LTI ATS:

API Gateway / Application Server (Spring Boot / Node.js): Es el punto de entrada principal para las peticiones de la capa de Edge. Expone los endpoints REST o GraphQL para la comunicación con los clientes.
Domain Services (Arquitectura Hexagonal): Contiene la lógica de negocio y se encarga de orquestar los casos de uso. Mediante adaptadores, se conecta con la capa de infraestructura (bases de datos, cache, colas, etc.).
Data & Messaging:

Base de Datos (PostgreSQL): Motor de persistencia relacional que almacena la información central (usuarios, ofertas, aplicaciones, etc.).
Cache (Redis): Sistema de caching para acelerar lecturas y reducir la carga en la base de datos.
Message Queue (RabbitMQ): Permite el procesamiento asíncrono y desacoplado de tareas (envío de notificaciones, procesamiento en segundo plano, etc.).
Servicios Externos:

External Integrations: Contenedor lógico para integraciones con otros servicios (envío de emails, SMS, análisis, etc.), que se comunican vía API (REST/HTTP) desde el API Gateway.
